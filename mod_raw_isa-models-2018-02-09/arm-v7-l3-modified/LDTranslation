
	
		   
-- TranslationTableWalkLD()
--
--			  Returns a result of a translation table walk using
--			  the longdescriptor in TLBRecord form
--			 
--			  Implementations might cache information from memory in any
--			  number of non-coherent TLB caching structures, and so avoid
--			  memory accesses that have been expressed in this pseudocode
--			  The use of such TLBs is not expressed in this pseudocode.


TLBRecord TranslationTableWalkLD (IA :: bits(40), va :: bits(32), is_write :: bool, stage1 :: bool, s2fs1walk :: bool, size :: int) =
{
	var result   :: TLBRecord;
	var walkaddr :: AddressDescriptor;
	
	var domain :: bits(4); -- UNKNOWN
	var LDFSRformat = true;
	var BaseAddress :: bits (40);
	BaseAddress <- 0::bits(40); 
	var BaseFound = false;
	var Disabled = false;
	if stage1 then
	   { if CurrentModeIsHyp() then
	      -- executing in Hyp mode	
	      {
	 		 var LookupSecure = false;
	 		 var T0Size = [CP15.HTCR.T0SZ] :: nat;
			 when T0Size == 0 or (T0Size == 1 and IsBVZero(IA<31:(32-1)>)) or
			   (T0Size == 2 and IsBVZero(IA<31:(32-2)>))  or (T0Size == 3 and IsBVZero(IA<31:(32-3)>)) or 
			   (T0Size == 4 and IsBVZero(IA<31:(32-4)>))  or (T0Size == 5 and IsBVZero(IA<31:(32-5)>)) or 
			   (T0Size == 6 and IsBVZero(IA<31:(32-6)>))  or (T0Size == 7 and IsBVZero(IA<31:(32-7)>)) or 
			   (T0Size == 8 and IsBVZero(IA<31:(32-8)>))  or (T0Size == 9 and IsBVZero(IA<31:(32-9)>)) or 
			   (T0Size == 10 and IsBVZero(IA<31:(32-10)>))  or (T0Size == 11 and IsBVZero(IA<31:(32-11)>)) or 
			   (T0Size == 12 and IsBVZero(IA<31:(32-12)>))  or (T0Size == 13 and IsBVZero(IA<31:(32-13)>)) or 
			   (T0Size == 14 and IsBVZero(IA<31:(32-14)>))  or (T0Size == 15 and IsBVZero(IA<31:(32-15)>))  
			       
			 do {
			 var CurrentLevel = (if CP15.HTCR.T0SZ<2:1> == 0`2 then 1 else 2);
			 var BALowerBound = 9*CurrentLevel - T0Size - 4;
			 BaseAddress<39:0> <- CP15.&HTTBR<39:BALowerBound> : 0`BALowerBound;
			 when !IsBVZero((CP15.&HTTBR)<BALowerBound-1:3>) do #UNPREDICTABLE("HTTBR not zero");
			 BaseFound = true;
			 var StartBit = 31-T0Size;
			 
			 -- unpack type information from HTCR 
			 walkaddr.memattrs.MemType <- MemType_Normal;
			 var hintsattrs = ConvertAttrsHints(CP15.HTCR.IRGN0);
			 walkaddr.memattrs.innerhints <- hintsattrs<3:2>;
			 walkaddr.memattrs.innerattrs <- hintsattrs<1:0>;
			 hintsattrs <- ConvertAttrsHints(CP15.HTCR.ORGN0);
			 walkaddr.memattrs.outerhints <- hintsattrs<3:2>; 
			 walkaddr.memattrs.outerattrs <- hintsattrs<1:0>; 
			 walkaddr.memattrs.shareable <- CP15.HTCR.SH0<1>;
			 walkaddr.memattrs.outershareable <- (CP15.HTCR.SH0 == '10');
			 walkaddr.memattrs.shareable <- CP15.HTCR.SH0<1> ;
		     walkaddr.memattrs.outershareable <- (CP15.HTCR.SH0 == '10');
			 walkaddr.paddress.NS <- '1'
		     };
			 
		  }
	   else
	   -- not executing in Hyp mode
	     {
		   var LookupSecure;
		   LookupSecure <-  IsSecure();
	       var T0Size <- [CP15.TTBCR.T0SZ] :: nat;
		   when T0Size == 0 or (T0Size == 1 and IsBVZero(IA<31:(32-1)>)) or
		   	  	(T0Size == 2 and IsBVZero(IA<31:(32-2)>))  or (T0Size == 3 and IsBVZero(IA<31:(32-3)>)) or 
		   		(T0Size == 4 and IsBVZero(IA<31:(32-4)>))  or (T0Size == 5 and IsBVZero(IA<31:(32-5)>)) or 
		   		(T0Size == 6 and IsBVZero(IA<31:(32-6)>))  or (T0Size == 7 and IsBVZero(IA<31:(32-7)>)) or 
		   		(T0Size == 8 and IsBVZero(IA<31:(32-8)>))  or (T0Size == 9 and IsBVZero(IA<31:(32-9)>)) or 
		   		(T0Size == 10 and IsBVZero(IA<31:(32-10)>))  or (T0Size == 11 and IsBVZero(IA<31:(32-11)>)) or 
		   		(T0Size == 12 and IsBVZero(IA<31:(32-12)>))  or (T0Size == 13 and IsBVZero(IA<31:(32-13)>)) or 
		   		(T0Size == 14 and IsBVZero(IA<31:(32-14)>))  or (T0Size == 15 and IsBVZero(IA<31:(32-15)>)) 
		   do {
		   var CurrentLevel = (if TTBCR.T0SZ<2:1> == 0`2 then 1 else 2); 
		   BALowerBound = 9*CurrentLevel - T0Size - 4;
		   BaseAddress<39:0> = TTBR0<39:BALowerBound>:Zeros(BALowerBound); 
		   when !IsZero(TTBR0<BALowerBound-1:3>) do #UNPREDICTABLE("");
		   BaseFound <- tru;
		   Disabled <- (TTBCR.EPD0 == '1');
		   var StartBit = 31-T0Size;
			 
		   -- unpack type information from TTBCR 
		   walkaddr.memattrs.MemType <- MemType_Normal;
		   var hintsattrs = ConvertAttrsHints(TTBCR.IRGN0);
		   walkaddr.memattrs.innerhints <- hintsattrs<3:2>;
		   walkaddr.memattrs.innerattrs <- hintsattrs<1:0>;
		   hintsattrs <- ConvertAttrsHints(TTBCR.ORGN0);
		   walkaddr.memattrs.outerhints <- hintsattrs<3:2>; 
		   walkaddr.memattrs.outerattrs <- hintsattrs<1:0>;
		   walkaddr.memattrs.shareable <- (TTBCR.SH0<1> == '1');
		   walkaddr.memattrs.outershareable <- (TTBCR.SH0 == '10')
			};
	       
	   var T1Size = [TTBCR.T1SZ]:: nat;
	   when (T1Size == 0 && !BaseFound) || IsOnes(IA<31:(32-T1Size)>) 
	   do
	   {
	   CurrentLevel = (if TTBCR.T1SZ<2:1> == '00' then 1 else 2);
	   BALowerBound = 9*CurrentLevel - T1Size - 4;
	   BaseAddress<39:0> = TTBR1<39:BALowerBound>:Zeros(BALowerBound);
	   when !IsZero(TTBR1<BALowerBound-1:3>) do #UNPREDICTABLE("");
	   BaseFound = TRUE;
	   Disabled = (TTBCR.EPD1 == '1');
	   StartBit = 31-T1Size;
	   
	   
	   -- unpack type information from TTBCR 
	   walkaddr.memattrs.type = MemType_Normal;
	   hintsattrs = ConvertAttrsHints(TTBCR.IRGN1); 
	   walkaddr.memattrs.innerhints = hintsattrs<3:2>;
	   walkaddr.memattrs.innerattrs = hintsattrs<1:0>;
	   hintsattrs = ConvertAttrsHints(TTBCR.ORGN1);
	   walkaddr.memattrs.outerhints = hintsattrs<3:2>;
	   walkaddr.memattrs.outerattrs = hintsattrs<1:0>; 
	   walkaddr.memattrs.shareable = (TTBCR.SH1<1> == '1');
	   walkaddr.memattrs.outershareable = (TTBCR.SH1 == '10')
   };
  }
	
	 
	} 
	 
	else 
	-- not a stage 1 translation
	{
	T0Size = SInt(VTCR.T0SZ);
	SLevel = UInt(VTCR.SL0);
	BALowerBound = 14 - T0Size - 9*SLevel;
	-- check UNPREDICTABLE combinations of the Starting level and Size fields 
	-- and check the VTTBR is aligned correctly
	when SLevel == 0 && T0Size < -2 do #UNPREDICTABLE("");
	when SLevel == 1 && T0Size > 1 do #UNPREDICTABLE("");
	when VTCR.SL0<1> == '1' do #UNPREDICTABLE("");
	when IsZero(VTTBR<BALowerBound-1:3>) == FALSE do #UNPREDICTABLE("");
	
	when T0Size == -8 || IsZero(IA<39:(32-T0Size)>) do
	{
	CurrentLevel = 2-SLevel;
	BaseAddress<39:0> = VTTBR<39:BALowerBound>:Zeros(BALowerBound);
	 BaseFound = TRUE;
	StartBit = 31-T0Size 
    }; 
	LookupSecure = FALSE;	
	
	-- unpack type information from VTCR 
	walkaddr.memattrs.type = MemType_Normal;
	hintsattrs = ConvertAttrsHints(VTCR.IRGN0);
	walkaddr.memattrs.innerhints = hintsattrs<3:2>;
	walkaddr.memattrs.innerattrs = hintsattrs<1:0>;
	hintsattrs = ConvertAttrsHints(VTCR.ORGN0);
	walkaddr.memattrs.outerhints = hintsattrs<3:2>;
    walkaddr.memattrs.outerattrs = hintsattrs<1:0>;
    walkaddr.memattrs.shareable = (VTCR.SH0<1> == '1'); 
    walkaddr.memattrs.outershareable = (VTCR.SH0 == '10');
}
  when !BaseFound || Disabled do
  {
  taketohypmode = CurrentModeIsHyp() || !stage1;
  level = 1;
  ipavalid = !stage1;
  DataAbort(va, IA, domain, level, is_write, DAbort_Translation,
  taketohypmode, !stage1, ipavalid, LDFSRformat, s2fs1walk);
};

FirstIteration = TRUE; 
TableRW = TRUE;
 TableUser = TRUE; 
 TableXN = FALSE; 
 TablePXN = FALSE;
 
 
 repeat
 {
  LookUpFinished = TRUE;
  BlockTranslate = FALSE; 
  Offset = 9*CurrentLevel; 
  if FirstIteration then
    IASelect = ZeroExtend(IA<StartBit:39-Offset>:'000', 40);
  else
    IASelect = ZeroExtend(IA<47-Offset:39-Offset>:'000', 40); 
  LookupAddress = BaseAddress OR IASelect;
  
  FirstIteration = FALSE;
 
 -- If there are two stages of translation, then the stage 1 
 --table walk addresses are themselves subject to translation
  walkaddr.paddress.physicaladdress = LookupAddress<39:0>;
 if LookupSecure then
   walkaddr.paddress.NS = '0'; 
 else
   walkaddr.paddress.NS = '1';
   
 if !HaveVirtExt() || !stage1 || IsSecure() || CurrentModeIsHyp() then
 {-- if only 1 stage of translation
    if HaveVirtExt() && (CurrentModeIsHyp() || !stage1) then
        BigEndian = (HCTLR.EE == '1'); 
    else
      BigEndian = SCTLR.EE == '1';
   Descriptor = _Mem[walkaddr,8]; 
   when BigEndian do Descriptor = BigEndianReverse(Descriptor,8);
}
  else
 {
 walkaddr2 = SecondStageTranslate(walkaddr, ia<31:0>); 
 Descriptor = _Mem[walkaddr2, 8] ;
 when SCTLR.EE == '1' do
 Descriptor = BigEndianReverse(Descriptor,8);
}


 if Descriptor<0> == '0' then
 {taketohypmode = CurrentModeIsHyp() || !stage1;
  ipavalid = TRUE;
 DataAbort(va, IA, domain, CurrentLevel, is_write,
 DAbort_Translation, taketohypmode, !stage1, ipavalid, LDFSRformat, s2fs1walk);}
 else
 {
 if 
 {
	 Descriptor<1> == '0' then
    if CurrentLevel == 3 then
    {
 	   taketohypmode = CurrentModeIsHyp() || !stage1; 
 	   ipavalid = TRUE;
 	   DataAbort(va, IA, domain, CurrentLevel, is_write, DAbort_Translation, taketohypmode, !stage1, ipavalid, LDFSRformat, s2fs1walk);}
    else
       BlockTranslate = TRUE;
   }
 else
    if CurrentLevel == 3 then BlockTranslate = TRUE
	
 else --table translation
 {
 BaseAddress = Descriptor<39:12>:'000000000000';
  LookupSecure = LookupSecure && (Descriptor<63> == '0'); 
  TableRW = TableRW && (Descriptor<62> == '0');
 TableUser = TableUser && (Descriptor<61> == '0'); 
 TablePXN = TablePXN || (Descriptor<59> == '1');
 TableXN = TableXN || (Descriptor<60> == '1');
  LookUpFinished = FALSE;
}
}

  if BlockTranslate then
  {
  OutputAddress = Descriptor<39:39-Offset> : IA<38-Offset:0>; 
  Attrs = Descriptor<54:52>: Descriptor<11:2>;
  
  when stage1 do
  {
  when TableXN do Attrs<12> = '1';
  when TablePXN do Attrs<11> = '1';
  when IsSecure() && !(LookupSecure) do Attrs<9> = '1'; 
  when !(TableRW) do Attrs<5> = '1';
  when !(TableUser) do Attrs<4> = '0';
  when !(LookupSecure) do Attrs<3> = '1';
}
}
  else
  CurrentLevel = CurrentLevel + 1;
 } until LookUpFinished
 
 
 
 
 -- check the access flag 
 when Attr<8> == '0' do
 {
 taketohypmode = CurrentModeIsHyp() || !stage1;
  ipavalid = TRUE;
 DataAbort(va, IA, domain, CurrentLevel, is_write,
 DAbort_AccessFlag, taketohypmode, !stage1, ipavalid, LDFSRformat, s2fs1walk);
}
 result.perms.xn = Attrs<12>; 
 result.perms.pxn = Attrs<11>;
  result.contiguoushint = Attrs<10>;
 result.nG = Attrs<9>;
 
 result.perms.ap<2:1> = Attrs<5:4>;
 
 result.perms.ap<0> = '1'; 
 if stage1 then
 result.addrdesc.memattrs = MAIRDecode(Attr<2:0>);
  else
 result.addrdesc.memattrs = S2AttrDecode(Attr<3:0>);
 
 
 -- check for alignment issues if memory type is SO or Device
 
 when result.addrdesc.memattrs == MemType_Device ||
 result.addrdesc.memattrs == MemType_StronglyOrdered do
 {when va != Align(va, size) do
 {TakeFaultInHypMode = !stage1 || CurrentModeIsHyp(); 
 AlignmentFaultV(va, FALSE, TakeFaultInHypMode);}
}
 if result.addrdesc.memattrs == MemType_Normal 
 then {result.addrdesc.shareable = (Attr<7> == '1');
 result.addrdesc.outershareable = (Attr<7:6> == '10'); }
 else
 {result.addrdesc.shareable = TRUE; 
 result.addrdesc.outshareable = TRUE;}
 
 result.domain = bits(4) UNKNOWN; -- domains not used 
result.level = CurrentLevel;
 result.blocksize = 512^(3-CurrentLevel)*4;
  result.addrdesc.paddress.physicaladdress = OutputAddress<39:0>;
  
 if stage1 then
 result.addrdesc.paddress.NS = Attrs<3>;
 else
 result.addrdesc.paddress.NS = '1';
 
 -- not all bits are legal in Hyp mode
 when stage1 && CurrentModeIsHyp() do
 {when Attrs<4> != '1' do UNPREDICTABLE; 
 when !TableUser do UNPREDICTABLE;
 when Attrs<11> != '0' do UNPREDICTABLE; 
 when !TablePXN do UNPREDICTABLE;
 when Attrs<9> != '0' do UNPREDICTABLE;
}
  return result;
		
	
}
								   



